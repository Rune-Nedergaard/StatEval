# Calculate path height (diference between max and min height)
path_height <- max(z) - min(z)
# Define distance between object and
d <- exp_setups[[i]][[1]]
# Define obstacle height
obstacle_height <- exp_setups[[i]][[2]]
curve_dist <- 0
prev_point <- NA
# Loop through all points and sum distance between points
for (n in 1:nrow(repetition)){
if (!is.na(sum(prev_point))){
curve_dist <- curve_dist + getDist3d(repetition[n,], prev_point)
}
prev_point <- repetition[n,]
}
paths <- rbind(paths, c(i, d, obstacle_height, j, k, path_height, z_vertex, x_vertex, y_range, y_std, z_min, curve_dist))
}
}
}
# Crate dataframe from matrix
paths <- data.frame(paths)
# Add column names
colnames(paths) <- c("Experiment", "d" , "obstacleHeight", "Person", "Repetition", "pathHeight", "zVertex", "xVertex", "yRange", "yStd", "zMin", "pathDist")
head(paths)
# Define variables as factors
paths$Experiment <- as.factor(paths$Experiment)
paths$Person <- as.factor(paths$Person)
paths$Repetition <- as.factor(paths$Repetition)
jpeg(file= getJpgFilePath("boxplot_pathHeight_obstacleHeight"))
boxplot(paths$pathHeight ~ paths$obstacleHeight, ylab="path height", xlab="Obstacle height")
dev.off()
jpeg(file= getJpgFilePath("boxplot_xVertex_d"))
boxplot(paths$xVertex ~ paths$d, ylab="x vertex", xlab="d")
dev.off()
jpeg(file= getJpgFilePath("boxplot_pathHeight_person"))
boxplot(paths$pathHeight ~ paths$Person, ylab="path distance", xlab="Person")
dev.off()
jpeg(file= getJpgFilePath("boxplot_pathDist_person"))
boxplot(paths$pathDist ~ paths$Person, ylab="path distance", xlab="Person")
dev.off()
L <- lm()
curve_dist
paths$pathDist
table(paths$pathDist)
table(paths$Per)
person10dist = paths$pathDist %>% filter(paths$Per == "10")
install.packages("magrittr")
install.packages("magrittr")
install.packages("magrittr")
install.packages("magrittr")
install.packages("magrittr")
install.packages("magrittr")
install.packages("dplyr")
install.packages("dplyr")
install.packages("dplyr")
library(magrittr)
library(dplyr)
person10dist = paths$pathDist %>% filter(paths$Per == "10")
person10dist = paths$pathDist %>% filter(paths$Per == 10)
paths$pathDist %>% filter(paths$Per == 10)
paths$pathDist %>% filter(paths$pathDist > 100)
names(paths)
paths["d"]
paths[["d"]]
table(paths$Per)
paths[(paths$Person == 10)]
paths[(paths$Person == "10")]
paths[paths$Person == "10"]
paths[paths$Person == 10]
paths[paths$Person == 10,]
# Load cleaned data
armdata <- readRDS("armdata_cleaned.rds")
# Create jpg file path for plots by providing a plot name
getJpgFilePath <- function(plot_name) {
plots_path <- "plots"
file_type <- "jpg"
path <- paste(paste(plots_path, plot_name, sep="/"), file_type, sep=".")
}
getDist3d <- function(v1, v2) {
dist <- sqrt((v2[1] - v1[1])^2 + (v2[2]- v1[2])^2 + (v2[3]- v1[3])^2)
return(dist)
}
# Define experiment setups
exp_setups <- data.frame(exp1 = c(15.0, 20),
exp2 = c(15.0, 27.5),
exp3 = c(15.0, 35),
exp4 = c(22.5, 20),
exp5 = c(22.5, 27.5),
exp6 = c(22.5, 35),
exp7 = c(30.0, 20),
exp8 = c(30.0, 27.5),
exp9 = c(30.0, 35),
exp10 = c(37.5, 20),
exp11 = c(47.5, 27.5),
exp12 = c(37.5, 35),
exp13 = c(45.0, 20),
exp14 = c(45.0, 27.5),
exp15 = c(45.0, 35),
exp16 = c(0,0)
)
# Set experiment setup names
row.names(exp_setups) <- c("d","obstacle_height")
# number of experiments (first layer )
n_experiments <- length(armdata);n_experiments
# number of persons (second layer)
n_participants <- length(armdata[[1]]
);n_participants
# number of repetitions (third layer)
n_repetitions <- length(armdata[[1]][[1]]);n_repetitions
# Matrix of path stats
paths <- c()
# Loop through experiments
for (i in 1:n_experiments){
# Loop through participants
for (j in 1:length(armdata[[i]])){
# Loop through repetitions
for (k in 1:length(armdata[[i]][[j]])){
# Define repetition
repetition <- armdata[[i]][[j]][[k]]
# Define coordinates
x <- repetition[,1]
y <- repetition[,2]
z <- repetition[,3]
# Get x-value of highest point on path (vertex of path)
x_vertex <- repetition[which.max(z), 1]
# Get z-value of highest point on path (vertex of path)
z_vertex <- repetition[which.max(z), 3]
# Calculate y-value range
y_range <- abs(max(y) - min(y))
# y standard deviation
y_std <- sd(y)
z_min <- min(repetition[,3])
# Calculate path height (diference between max and min height)
path_height <- max(z) - min(z)
# Define distance between object and
d <- exp_setups[[i]][[1]]
# Define obstacle height
obstacle_height <- exp_setups[[i]][[2]]
curve_dist <- 0
prev_point <- NA
# Loop through all points and sum distance between points
for (n in 1:nrow(repetition)){
if (!is.na(sum(prev_point))){
curve_dist <- curve_dist + getDist3d(repetition[n,], prev_point)
}
prev_point <- repetition[n,]
}
paths <- rbind(paths, c(i, d, obstacle_height, j, k, path_height, z_vertex, x_vertex, y_range, y_std, z_min, curve_dist))
}
}
}
# Crate dataframe from matrix
paths <- data.frame(paths)
# Add column names
colnames(paths) <- c("Experiment", "d" , "obstacleHeight", "Person", "Repetition", "pathHeight", "zVertex", "xVertex", "yRange", "yStd", "zMin", "pathDist")
head(paths)
# Define variables as factors
paths$Experiment <- as.factor(paths$Experiment)
paths$Person <- as.factor(paths$Person)
paths$Repetition <- as.factor(paths$Repetition)
jpeg(file= getJpgFilePath("boxplot_pathHeight_obstacleHeight"))
boxplot(paths$pathHeight ~ paths$obstacleHeight, ylab="path height", xlab="Obstacle height")
dev.off()
jpeg(file= getJpgFilePath("boxplot_xVertex_d"))
boxplot(paths$xVertex ~ paths$d, ylab="x vertex", xlab="d")
dev.off()
jpeg(file= getJpgFilePath("boxplot_pathHeight_person"))
boxplot(paths$pathHeight ~ paths$Person, ylab="path distance", xlab="Person")
dev.off()
jpeg(file= getJpgFilePath("boxplot_pathDist_person"))
boxplot(paths$pathDist ~ paths$Person, ylab="path distance", xlab="Person")
dev.off()
L <- aov(pathDist ~ Experiment + PErson, data = paths)
L <- aov(pathDist ~ Experiment + Person, data = paths)
summary(L)
res.aov2 <- aov(pathDist ~ Experiment + Person, data = paths)
summary(res.aov2)
# Load cleaned data
armdata <- readRDS("armdata_cleaned.rds")
# Create jpg file path for plots by providing a plot name
getJpgFilePath <- function(plot_name) {
plots_path <- "plots"
file_type <- "jpg"
path <- paste(paste(plots_path, plot_name, sep="/"), file_type, sep=".")
}
getDist3d <- function(v1, v2) {
dist <- sqrt((v2[1] - v1[1])^2 + (v2[2]- v1[2])^2 + (v2[3]- v1[3])^2)
return(dist)
}
# Define experiment setups
exp_setups <- data.frame(exp1 = c(15.0, 20),
exp2 = c(15.0, 27.5),
exp3 = c(15.0, 35),
exp4 = c(22.5, 20),
exp5 = c(22.5, 27.5),
exp6 = c(22.5, 35),
exp7 = c(30.0, 20),
exp8 = c(30.0, 27.5),
exp9 = c(30.0, 35),
exp10 = c(37.5, 20),
exp11 = c(47.5, 27.5),
exp12 = c(37.5, 35),
exp13 = c(45.0, 20),
exp14 = c(45.0, 27.5),
exp15 = c(45.0, 35),
exp16 = c(0,0)
)
# Set experiment setup names
row.names(exp_setups) <- c("d","obstacle_height")
# number of experiments (first layer )
n_experiments <- length(armdata);n_experiments
# number of persons (second layer)
n_participants <- length(armdata[[1]]
);n_participants
# number of repetitions (third layer)
n_repetitions <- length(armdata[[1]][[1]]);n_repetitions
# Matrix of path stats
paths <- c()
# Loop through experiments
for (i in 1:n_experiments){
# Loop through participants
for (j in 1:length(armdata[[i]])){
# Loop through repetitions
for (k in 1:length(armdata[[i]][[j]])){
# Define repetition
repetition <- armdata[[i]][[j]][[k]]
# Define coordinates
x <- repetition[,1]
y <- repetition[,2]
z <- repetition[,3]
# Get x-value of highest point on path (vertex of path)
x_vertex <- repetition[which.max(z), 1]
# Get z-value of highest point on path (vertex of path)
z_vertex <- repetition[which.max(z), 3]
# Calculate y-value range
y_range <- abs(max(y) - min(y))
# y standard deviation
y_std <- sd(y)
z_min <- min(repetition[,3])
# Calculate path height (diference between max and min height)
path_height <- max(z) - min(z)
# Define distance between object and
d <- exp_setups[[i]][[1]]
# Define obstacle height
obstacle_height <- exp_setups[[i]][[2]]
curve_dist <- 0
prev_point <- NA
# Loop through all points and sum distance between points
for (n in 1:nrow(repetition)){
if (!is.na(sum(prev_point))){
curve_dist <- curve_dist + getDist3d(repetition[n,], prev_point)
}
prev_point <- repetition[n,]
}
paths <- rbind(paths, c(i, d, obstacle_height, j, k, path_height, z_vertex, x_vertex, y_range, y_std, z_min, curve_dist))
}
}
}
# Crate dataframe from matrix
paths <- data.frame(paths)
# Add column names
colnames(paths) <- c("Experiment", "d" , "obstacleHeight", "Person", "Repetition", "pathHeight", "zVertex", "xVertex", "yRange", "yStd", "zMin", "pathDist")
head(paths)
# Define variables as factors
paths$Experiment <- as.factor(paths$Experiment)
paths$Person <- as.factor(paths$Person)
paths$Repetition <- as.factor(paths$Repetition)
jpeg(file= getJpgFilePath("boxplot_pathHeight_obstacleHeight"))
boxplot(paths$pathHeight ~ paths$obstacleHeight, ylab="path height", xlab="Obstacle height")
dev.off()
jpeg(file= getJpgFilePath("boxplot_xVertex_d"))
boxplot(paths$xVertex ~ paths$d, ylab="x vertex", xlab="d")
dev.off()
jpeg(file= getJpgFilePath("boxplot_pathHeight_person"))
boxplot(paths$pathHeight ~ paths$Person, ylab="path distance", xlab="Person")
dev.off()
jpeg(file= getJpgFilePath("boxplot_pathDist_person"))
boxplot(paths$pathDist ~ paths$Person, ylab="path distance", xlab="Person")
dev.off()
L <- aov(pathDist ~ Experiment + Person, data = paths)
summary(L)
'# L <- lm(pathHeight ~ . , data = paths)
# anova(L)
# interaction.plot(paths$Experiment, paths$Person, paths$pathHeight)
#
# anv <- aov(pathHeight ~ Person + Experiment, data = paths)
# plot(anv)
#
# # L <- lm(paths$pathHeight ~ paths$Person , data = paths)
# anova(L)
#
# L <- lm(paths$xVertex ~ paths$Person , data = paths)
# anova(L)
#
#
# plot(L)
#
# summary(L)
#
#
#
# s <- paths[paths$Experiment == 2,]
#
#
#
# # path height
# boxplot(s$pathHeight ~ s$Person, ylab="path height", xlab="Person")
#
# kruskal.test(s$pathHeight, s$Person)
#
# pairwise.wilcox.test(s$pathHeight, s$Person,
#                      p.adjust.method = "BH")
#
#
#
#
# # path height
# boxplot(paths$pathHeight ~ paths$Person, ylab="path height", xlab="Person")
#
# kruskal.test(paths$pathHeight, paths$Person)
#
# pairwise.wilcox.test(paths$pathHeight, paths$Person,
#                      p.adjust.method = "BH")
#
#
# # x-coordinate, toppunkt
# boxplot(paths$xVertex ~ paths$Person, ylab="xVertex", xlab="Person")
#
# kruskal.test(paths$xVertex, paths$Person)
#
# pairwise.wilcox.test(paths$xVertex, paths$Person,
#                      p.adjust.method = "BH")
#
#
# # yRange
# boxplot(paths$yRange ~ paths$Person, ylab="yRange", xlab="Person")
#
# kruskal.test(paths$yRange, paths$Person)
#
# pairwise.wilcox.test(paths$yRange, paths$Person,
#                      p.adjust.method = "BH")
#
#
#
#
#
# pairwise
#
# ?kruskal.test
#
# L <- lm(obstacleHeight ~ pathHeight, data = paths)
# anova(L)
#
#
# predict.lm()
#
# L <- lm(obstacleHeight ~ xVertex, data = paths)
# anova(L)
#
# # Check for interaction
# L <- lm(obstacleHeight ~ pathHeight * xVertex, data = paths)
# anova(L)
library(magrittr)
library(dplyr)
table(paths$Per)
paths[paths$Person == 10,]
#load data
load('armdata.RData')
### below is taken from: https://gitlab.gbar.dtu.dk/s183897_s183926_s183924/Project_1 ###
data <- as.matrix(armdata)
s <- c() # Make a matrix of our path statistics
e <- 1
for (experiment in armdata) {
p <- 1
for (person in experiment) {
r <- 1
for (repetition in person) {
repetition[is.na(repetition)] <- 0 # Remove NAs
z.max <- max(repetition[,3])
x.argmax <- which.max(repetition[,3])
x.max <- repetition[x.argmax, 1]
y.range <- abs(max(repetition[,2]) - min(repetition[,2]))
y.std <- sd(repetition[,2])
z.min <- min(repetition[,3])
h <- z.max - z.min
s <- rbind(s, c(e, p, r, h, z.max, x.max, y.range, y.std, z.min))
r <- r + 1
}
p <- p + 1
}
e <- e + 1
}
# Make a nice data frame
s <- data.frame(s)
colnames(s) <- c("Exp", "Per", "Rep", "height", "z_max", "x", "y_range", "y_std", "z_min")
s$Exp <- as.factor(s$Exp)
s$Per <- as.factor(s$Per)
s$Rep <- as.factor(s$Rep)
boxplot(s$height ~ s$Exp)
hist(s$x, breaks=40)
l <- lm(s$height ~ s$Per*z_max*x*y_range)
anova(l)
drop1(l, test = "F")
par(mfrow=c(2, 2))
boxplot(s$height ~ s$Exp)
boxplot(s$height ~ s$Per)
boxplot(s$x ~ s$Exp)
boxplot(s$x ~ s$Per)
par(mfrow=c(1,1))
interaction.plot(s$Exp, s$Per, s$height)
# P-adjust using method
p.adjust(c(2.2e-16,2.2e-16), method = 'hochberg')
library(ggplot2)
library(cowplot)
p <- ggplot(ToothGrowth, aes(x=dose, y=len)) +
geom_boxplot()
head(s)
str(s)
nrow(s)
smp_size <- floor(0.75 * nrow(s))
set.seed(42)
train_ind <- sample(seq_len(nrow(s)), size = smp_size)
train <- s[train_ind, ]
test <- s[-train_ind, ]
require(nnet)
# Setting the baseline
train$Per <- relevel(train$Per, ref = "1")
multinom.fit <- multinom(Per ~ height, data=train)
#load data
load('armdata.RData')
### below is taken from: https://gitlab.gbar.dtu.dk/s183897_s183926_s183924/Project_1 ###
data <- as.matrix(armdata)
s <- c() # Make a matrix of our path statistics
e <- 1
for (experiment in armdata) {
p <- 1
for (person in experiment) {
r <- 1
for (repetition in person) {
repetition[is.na(repetition)] <- 0 # Remove NAs
z.max <- max(repetition[,3])
x.argmax <- which.max(repetition[,3])
x.max <- repetition[x.argmax, 1]
y.range <- abs(max(repetition[,2]) - min(repetition[,2]))
y.std <- sd(repetition[,2])
z.min <- min(repetition[,3])
h <- z.max - z.min
s <- rbind(s, c(e, p, r, h, z.max, x.max, y.range, y.std, z.min))
r <- r + 1
}
p <- p + 1
}
e <- e + 1
}
# Make a nice data frame
s <- data.frame(s)
colnames(s) <- c("Exp", "Per", "Rep", "height", "z_max", "x", "y_range", "y_std", "z_min")
s$Exp <- as.factor(s$Exp)
s$Per <- as.factor(s$Per)
s$Rep <- as.factor(s$Rep)
boxplot(s$height ~ s$Exp)
hist(s$x, breaks=40)
l <- lm(s$height ~ s$Per*z_max*x*y_range)
anova(l)
drop1(l, test = "F")
par(mfrow=c(2, 2))
boxplot(s$height ~ s$Exp)
boxplot(s$height ~ s$Per)
boxplot(s$x ~ s$Exp)
boxplot(s$x ~ s$Per)
par(mfrow=c(1,1))
interaction.plot(s$Exp, s$Per, s$height)
# P-adjust using method
p.adjust(c(2.2e-16,2.2e-16), method = 'hochberg')
library(ggplot2)
library(cowplot)
p <- ggplot(ToothGrowth, aes(x=dose, y=len)) +
geom_boxplot()
head(s)
str(s)
nrow(s)
smp_size <- floor(0.75 * nrow(s))
set.seed(42)
train_ind <- sample(seq_len(nrow(s)), size = smp_size)
train <- s[train_ind, ]
test <- s[-train_ind, ]
require(nnet)
# Setting the baseline
train$Per <- relevel(train$Per, ref = "1")
multinom.fit <- multinom(Per ~ height, data=train)
summary(multinom.fit)
# Predicting the values for train dataset
train$precticed <- predict(multinom.fit, newdata = train, "class")
# Building classification table
ctable <- table(train$Per, train$precticed)
# Calculating accuracy - sum of diagonal elements divided by total obs
round((sum(diag(ctable))/sum(ctable))*100,2)
C
multinom.fit <- multinom(Per ~ ., data=train)
summary(multinom.fit)
# Predicting the values for train dataset
train$precticed <- predict(multinom.fit, newdata = train, "class")
# Building classification table
ctable <- table(train$Per, train$precticed)
multinom.fit <- multinom(Exp ~ ., data=train)
summary(multinom.fit)
# Predicting the values for train dataset
train$precticed <- predict(multinom.fit, newdata = train, "class")
# Building classification table
ctable <- table(train$Per, train$precticed)
# Calculating accuracy - sum of diagonal elements divided by total obs
round((sum(diag(ctable))/sum(ctable))*100,2)
