path_height <- max(z) - min(z)
# Define distance between object and
d <- exp_setups[[i]][[1]]
# Define obstacle height
obstacle_height <- exp_setups[[i]][[2]]
curve_dist <- 0
prev_point <- NA
# Loop through all points and sum distance between points
for (n in 1:nrow(repetition)){
if (!is.na(sum(prev_point))){
curve_dist <- curve_dist + getDist3d(repetition[n,], prev_point)
}
prev_point <- repetition[n,]
}
paths <- rbind(paths, c(i, d, obstacle_height, j, k, path_height, z_vertex, xz_vertex, xy_max, xy_min, y_shakiness_mean, y_shakiness_std, yz_max, y_range, y_std, x_std, z_std, z_min, curve_dist))
}
}
}
# Crate dataframe from matrix
paths <- data.frame(paths)
# Add column names
colnames(paths) <- c("Experiment", "d" , "obstacleHeight", "Person", "Repetition", "pathHeight", "zVertex", "xzVertex","xyMax","xyMin","yShakinessMean","yShakinessStd","yzMax", "yRange", "yStd","xStd","zStd", "zMin", "pathDist")
head(paths)
# Define variables as factors
paths$Experiment <- as.factor(paths$Experiment)
paths$Person <- as.factor(paths$Person)
paths$Repetition <- as.factor(paths$Repetition)
paths$d <- as.factor(paths$d)
paths$obstacleHeight <- as.factor(paths$obstacleHeight)
par(mfrow=c(1,1))
plot(paths$Experiment,paths$yShakinessMean, main= "yShakinessMean")
plot(paths$Experiment,paths$yShakinessStd, main= "yShakinessStd")
plot(paths$Experiment,paths$zMin, main= "Zmin")
###########################################################
#                       MODELLING                         #
###########################################################
require(nnet)
library(modelr)
library(purrr)
library(dplyr)
library(ggplot2)
library(yardstick)
library(MASS)
folds <- 30
cv <- crossv_kfold(paths, k = folds);cv
#For doing stepAIC
multinom.fit <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
boxTidwell(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist)
boxTidwell(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
boxTidwell(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
library(boxTidwell)
library(car)
boxTidwell(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
###### Cross-Validation ##########
multinom.fit.cv <- map(cv$train, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = .))
get_pred  <- function(model, test_data){
data  <- as.data.frame(test_data)
pred  <- add_predictions(data, model)
return(pred)
}
pred <- map2_df(multinom.fit.cv, cv$test, get_pred, .id = "Fold");pred
Acc  <- pred %>% group_by(Fold) %>%
summarise(Acc = round((sum(diag(table(Experiment, pred)))/sum(table(Experiment, pred)))*100,2),
Baseline = round((sum(diag(table(Experiment, Baseline)))/sum(table(Experiment, Baseline)))*100,2))
Acc  <- pred %>% group_by(Fold) %>%
summarise(Acc = round((sum(diag(table(Experiment, pred)))/sum(table(Experiment, pred)))*100,2),
Baseline = round((sum(diag(table(Experiment, Baseline)))/sum(table(Experiment, Baseline)))*100,2))
# Confusionmatrix for Model
truth_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
truth_predicted$obs <- as.factor(truth_predicted$obs)
truth_predicted$pred <- as.factor(truth_predicted$pred)
cm <- conf_mat(truth_predicted, obs, pred)
cm
autoplot(cm, type = "heatmap") +
scale_fill_gradient(low = "white", high = "orange")
# Confidence interval for model
CI <- quantile(pull(Acc, Acc), probs = c(0.025, 0.975));CI
install.packages("glmnet")
library(glmnet)
# this method controls everything about training
# we will just set up 10-fold cross validation
trctrl <- trainControl(method = "cv",number=10)
====================================================
# Create jpg file path for plots by providing a plot name
getJpgFilePath <- function(plot_name) {
plots_path <- "plots"
file_type <- "jpg"
path <- paste(paste(plots_path, plot_name, sep="/"), file_type, sep=".")
}
getDist3d <- function(v1, v2) {
dist <- sqrt((v2[1] - v1[1])^2 + (v2[2]- v1[2])^2 + (v2[3]- v1[3])^2)
return(dist)
}
# =======================================================
# Load/prepare data
# =======================================================
# Load cleaned data
armdata <- readRDS("armdata_cleaned.rds")
armdata[[1]][[1]]
# Define experiment setups
exp_setups <- data.frame(exp1 = c(15.0, 20),
exp2 = c(15.0, 27.5),
exp3 = c(15.0, 35),
exp4 = c(22.5, 20),
exp5 = c(22.5, 27.5),
exp6 = c(22.5, 35),
exp7 = c(30.0, 20),
exp8 = c(30.0, 27.5),
exp9 = c(30.0, 35),
exp10 = c(37.5, 20),
exp11 = c(47.5, 27.5),
exp12 = c(37.5, 35),
exp13 = c(45.0, 20),
exp14 = c(45.0, 27.5),
exp15 = c(45.0, 35),
exp16 = c(0,0)
)
# Set experiment setup names
row.names(exp_setups) <- c("d","obstacle_height")
# number of experiments (first layer )
n_experiments <- length(armdata);n_experiments
# number of persons (second layer)
n_participants <- length(armdata[[1]]
);n_participants
# number of repetitions (third layer)
n_repetitions <- length(armdata[[1]][[1]]);n_repetitions
# Matrix of path stats
paths <- c()
# Loop through experiments
for (i in 1:n_experiments){
# Loop through participants
for (j in 1:length(armdata[[i]])){
# Loop through repetitions
for (k in 1:length(armdata[[i]][[j]])){
# Define repetition
repetition <- armdata[[i]][[j]][[k]]
# Define coordinates
x <- repetition[,1]
y <- repetition[,2]
z <- repetition[,3]
# Get x-value of highest point on path (vertex of path)
xz_vertex <- repetition[which.max(z), 1]
# Get z-value of highest point on path (vertex of path)
z_vertex <- repetition[which.max(z), 3]
# Get x-value where y is max
xy_max <- repetition[which.max(y),1]
# Get x-value where y is min
xy_min <- repetition[which.min(y),1]
# See how inefficient people move in y-axis
nulls <- rep(0,length(y))
#y_shakiness <- abs(nulls-y)
y_shakiness_mean <- mean(abs(nulls-y))
y_shakiness_std <- sd(abs(nulls-y))
yz_max <- repetition[which.max(z),2]
# par(mfrow = c(1,2))
# plot(x,y_shakiness)
# abline(v = xz_vertex)
# plot(x,z)
# abline(v = xz_vertex)
#
# Calculate y-value range
y_range <- abs(max(y) - min(y))
# y standard deviation
y_std <- sd(y)
#x standard deviation
x_std <- sd(x)
#z staandard deviation
z_std <- sd(z)
z_min <- min(repetition[,3])
# Calculate path height (diference between max and min height)
path_height <- max(z) - min(z)
# Define distance between object and
d <- exp_setups[[i]][[1]]
# Define obstacle height
obstacle_height <- exp_setups[[i]][[2]]
curve_dist <- 0
prev_point <- NA
# Loop through all points and sum distance between points
for (n in 1:nrow(repetition)){
if (!is.na(sum(prev_point))){
curve_dist <- curve_dist + getDist3d(repetition[n,], prev_point)
}
prev_point <- repetition[n,]
}
paths <- rbind(paths, c(i, d, obstacle_height, j, k, path_height, z_vertex, xz_vertex, xy_max, xy_min, y_shakiness_mean, y_shakiness_std, yz_max, y_range, y_std, x_std, z_std, z_min, curve_dist))
}
}
}
# Crate dataframe from matrix
paths <- data.frame(paths)
# Add column names
colnames(paths) <- c("Experiment", "d" , "obstacleHeight", "Person", "Repetition", "pathHeight", "zVertex", "xzVertex","xyMax","xyMin","yShakinessMean","yShakinessStd","yzMax", "yRange", "yStd","xStd","zStd", "zMin", "pathDist")
head(paths)
# Define variables as factors
paths$Experiment <- as.factor(paths$Experiment)
paths$Person <- as.factor(paths$Person)
paths$Repetition <- as.factor(paths$Repetition)
paths$d <- as.factor(paths$d)
paths$obstacleHeight <- as.factor(paths$obstacleHeight)
library(glmnet)
# we will now train elastic net model
# it will try
enetFit <- train(Experiment~., data = paths,
method = "glmnet",
trControl=trctrl,
# alpha and lambda paramters to try
tuneGrid = data.frame(alpha=0.5,
lambda=seq(0.1,0.7,0.05)))
library(glmnet)
lrFit = train(Experiment ~ pathDist,
data=paths, trControl=trainControl("none"),
method="glm", family="binomial")
###########################################################
#                       MODELLING                         #
###########################################################
require(nnet)
library(modelr)
library(purrr)
library(dplyr)
library(ggplot2)
library(yardstick)
library(MASS)
folds <- 30
cv <- crossv_kfold(paths, k = folds);cv
################## STEP AIC ###################
#These are needed when not doing cv - when we do stepAIC
smp_size <- floor(0.75 * nrow(paths))
set.seed(666)
train_idx <- sample(seq_len(nrow(paths)), size = smp_size)
train_data <- paths[train_idx, ]
test_data <- paths[-train_idx, ]
#For doing stepAIC
multinom.fit <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
#For doing stepAIC
all_full <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
#For doing stepAIC
xyz_full <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
#For doing stepAIC
xyz_full <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data)
# Predicting the values for train dataset
test_data$xyz_full <- predict(xyz_full, newdata = test_data, "class")
test_data$xyz_full
ctable_test <- table(test_data$Experiment, test_data$xyz_full)
ctable_test
test_data
test_data$class
test_data$Experiment
sum(where(test_data$Experiment == test_data$xyz_full))/length/test_data$Experiment
mean(test_data$Experiment == test_data$xyz_full)
sum(test_data$Experiment == test_data$xyz_full)
ctabl_test
#For doing stepAIC
multinom.fit <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
# Predicting the values for train dataset
test_data$precticed <- predict(multinom.fit, newdata = test_data, "class")
# Building classification table
ctable_test <- table(test_data$Experiment, test_data$precticed)
# Calculating accuracy - sum of diagonal elements divided by total obs
test_error <- round((sum(diag(ctable_test))/sum(ctable_test))*100,2);test_error
#For doing stepAIC
xyz_full <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data)
# Predicting the values for train dataset
test_data$xyz_full <- predict(xyz_full, newdata = test_data, "class")
sum(test_data$Experiment == test_data$xyz_full)
ctable_test <- table(test_data$Experiment, test_data$xyz_full)
test_error <- round((sum(diag(ctable_test))/sum(ctable_test))*100,2);test_error
#For doing stepAIC
multinom.fit <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data)
# Predicting the values for train dataset
test_data$precticed <- predict(multinom.fit, newdata = test_data, "class")
# Building classification table
ctable_test <- table(test_data$Experiment, test_data$precticed)
# Calculating accuracy - sum of diagonal elements divided by total obs
test_error <- round((sum(diag(ctable_test))/sum(ctable_test))*100,2);test_error
stepAIC(xyz_full, direction = "both")
xyz_selected <- multinom(formula = Experiment ~ Person + pathHeight + zVertex +
xzVertex + yShakinessMean + zStd + zMin + pathDist, data = train_data)
test_data$xyz_selected <- predict(xyz_selected, newdata = test_data, "class")
sum(test_data$Experiment == test_data$xyz_selected) #50% acc
mean(test_data$Experiment == test_data$xyz_selected) #50% acc
#XY-coordinates only
xy_full <- multinom(Experiment ~ Person + Repetition
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yRange +
yStd +xStd + zMin, data = train_data)
test_data$xy_full <- predict(xy_full, newdata = test_data, "class")
mean(test_data$Experiment == test_data$xy_full) #50.00% acc
get_pred  <- function(model, test_data){
data  <- as.data.frame(test_data)
pred  <- add_predictions(data, model)
return(pred)
}
table(test_data$xyz_selected,test_data$xyz_full)
ctable <- test_data$Experiment == test_data$xyz_selected
ctable
ctable <- rep(0,length(test_data))
ctable$xyz_selected <- test_data$Experiment == test_data$xyz_selected
delete(ctable)
rm(ctable=
ctable(test_data$xyz_selected,test_data$xyz_full)
rm(ctable)
rm("ctable")
ctable$xyz_selected <- test_data$Experiment == test_data$xyz_selected
xyz_full.cv <- map(cv$xyz_full, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
multinom.fit.cv <- map(cv$xyz_full, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
folds <- 30
cv <- crossv_kfold(paths, k = folds);cv
xyz_full.cv <- map(cv$xyz_full, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
multinom.fit.cv <- map(cv$xyz_full, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
###### Cross-Validation ##########
multinom.fit.cv <- map(cv$train, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = .))
rm("cv")
folds <- 30
cv <- crossv_kfold(paths, k = folds);cv
multinom.fit.cv <- map(cv$xyz_full, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
multinom.fit.cv <- map(cv$train, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
View(cv)
View(cv)
cvxyz_full <- crossv_kfold(paths, k = folds)
multinom.fit.cvxyz_full <- map(cvxyz_full$train, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
pred <- map2_df(multinom.fit.cvxyz_full, cvxyz_full$test, get_pred, .id = "Fold");pred
truth_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
truth_predicted$obs <- as.factor(truth_predicted$obs)
truth_predicted$pred <- as.factor(truth_predicted$pred)
cm <- conf_mat(truth_predicted, obs, pred)
cm
pred
multinom.fit.cvxyz_full
xyz_full <- map(cvxyz_full$train, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
xyz_full
pred <- map2_df(xyz_full, cvxyz_full$test, get_pred, .id = "Fold")
truth_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
truth_predicted$obs <- as.factor(truth_predicted$obs)
truth_predicted$pred <- as.factor(truth_predicted$pred)
truth_predicted$obs
pred <- map2_df(xyz_full, cvxyz_full$test, get_pred, .id = "Fold")
truth_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
truth_predicted$obs <- as.factor(truth_predicted$obs)
truth_predicted$pred <- as.factor(truth_predicted$pred)
mean(truth_predicted$obs == truth_predicted$obs)
mean(truth_predicted$obs == truth_predicted$pred)
sum(truth_predicted$obs == truth_predicted$pred)
1600/960
960/1600
xyz_full_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
pred <- map2_df(xyz_full, cvxyz_full$test, get_pred, .id = "Fold")
xyz_full_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
xyz_full_predicted$obs <- as.factor(xyz_full_predicted$obs)
xyz_full_predicted$pred <- as.factor(xyz_full_predicted$pred)
mean(xyz_full_predicted$obs == xyz_full_predicted$pred) #60.00%
#stepAIC on xyz_full
stepAIC(xyz_full, direction = "both")
######### xyz_full ##########
xyz_full <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data)
xyz_full <- map(cvxyz_full$train, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data))
#stepAIC on xyz_full
stepAIC(xyz_full, direction = "both")
#stepAIC on xyz_full
xyz_full_nocv <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = train_data)
#stepAIC on xyz_full
xyz_full_nocv <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
stepAIC(xyz_full_nocv, direction = "both")
#CV on xyz_selected
cvxyz_selected <- crossv_kfold(paths, k = folds)
#CV on xyz_selected
cvxyz_selected <- crossv_kfold(paths, k = folds)
xyz_selected <- map(cvxyz_selected$train, ~multinom(Experiment ~ Person + pathHeight + zVertex +
+ yShakinessMean + xStd + zStd + zMin, data = train_data))
pred <- map2_df(xyz_selected, cvxyz_selected$test, get_pred, .id = "Fold")
xyz_selected_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
pred <- map2_df(xyz_selected, cvxyz_selected$test, get_pred, .id = "Fold")
xyz_selected_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
xyz_selected_predicted$obs <- as.factor(xyz_selected_predicted$obs)
xyz_selected_predicted$pred <- as.factor(xyz_selected_predicted$pred)
mean(xyz_selected_predicted$obs == xyz_selected_predicted$pred) #60.00%
pred <- map2_df(xyz_selected, cvxyz_selected$test, get_pred, .id = "Fold")
xyz_selected_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
xyz_selected_predicted$obs <- as.factor(xyz_selected_predicted$obs)
xyz_selected_predicted$pred <- as.factor(xyz_selected_predicted$pred)
mean(xyz_selected_predicted$obs == xyz_selected_predicted$pred) #60.00%
#CV on xyz_selected
cvxyz_selected <- crossv_kfold(paths, k = folds)
xyz_selected <- map(cvxyz_selected$train, ~multinom(Experiment ~ Person + pathHeight + zVertex +
+ yShakinessMean + xStd + zStd + zMin, data = paths))
######### xyz_full ##########
cvxyz_full <- crossv_kfold(paths, k = folds)
xyz_full <- map(cvxyz_full$train, ~multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths))
pred <- map2_df(xyz_full, cvxyz_full$test, get_pred, .id = "Fold")
xyz_full_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
xyz_full_predicted$obs <- as.factor(xyz_full_predicted$obs)
xyz_full_predicted$pred <- as.factor(xyz_full_predicted$pred)
mean(xyz_full_predicted$obs == xyz_full_predicted$pred) #60.00%
#stepAIC on xyz_full
xyz_full_nocv <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
#CV on xyz_selected
cvxyz_selected <- crossv_kfold(paths, k = folds)
xyz_selected <- map(cvxyz_selected$train, ~multinom(Experiment ~ Person + pathHeight + zVertex +
+ yShakinessMean + xStd + zStd + zMin, data = paths))
pred <- map2_df(xyz_selected, cvxyz_selected$test, get_pred, .id = "Fold")
xyz_selected_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
xyz_selected_predicted$obs <- as.factor(xyz_selected_predicted$obs)
xyz_selected_predicted$pred <- as.factor(xyz_selected_predicted$pred)
mean(xyz_selected_predicted$obs == xyz_selected_predicted$pred) #60.00%
xyz_selected <- map(cvxyz_selected$train, ~multinom(Experiment ~ Person + pathHeight + zVertex +
+ yShakinessMean + xStd + zStd + zMin, data = paths))
#stepAIC on xyz_full
xyz_full_nocv <- multinom(Experiment ~ Person + Repetition +pathHeight+ zVertex +xzVertex
+ xyMax + xyMin +yShakinessMean +yShakinessStd +yzMax +yRange +
yStd +xStd +zStd + zMin + pathDist, data = paths)
#Selecting features
stepAIC(xyz_full_nocv, direction = "both")
#CV on xyz_selected
cvxyz_selected <- crossv_kfold(paths, k = folds)
xyz_selected <- map(cvxyz_selected$train, ~multinom(Experiment ~ Person + pathHeight + zVertex +
+ yShakinessMean + xStd + zStd + zMin, data = .))
pred <- map2_df(xyz_selected, cvxyz_selected$test, get_pred, .id = "Fold")
xyz_selected_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
xyz_selected_predicted$obs <- as.factor(xyz_selected_predicted$obs)
xyz_selected_predicted$pred <- as.factor(xyz_selected_predicted$pred)
mean(xyz_selected_predicted$obs == xyz_selected_predicted$pred) #60.00%
xyz_selected <- multinom(formula = Experiment ~ Person + pathHeight + zVertex +
xzVertex + yShakinessMean + xStd + zStd + zMin, data = train_data)
test_data$xyz_selected <- predict(xyz_selected, newdata = test_data, "class")
mean(test_data$Experiment == test_data$xyz_selected) #61.75% acc
xyz_selected <- map(cvxyz_selected$train, ~multinom(Experiment ~ Person + pathHeight + zVertex + xzVertex +
+ yShakinessMean + xStd + zStd + zMin, data = .))
pred <- map2_df(xyz_selected, cvxyz_selected$test, get_pred, .id = "Fold")
xyz_selected_predicted <- data.frame(
obs = pred$Experiment,
pred = pred$pred)
xyz_selected_predicted$obs <- as.factor(xyz_selected_predicted$obs)
xyz_selected_predicted$pred <- as.factor(xyz_selected_predicted$pred)
mean(xyz_selected_predicted$obs == xyz_selected_predicted$pred) #60.00%
